package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"os"
	"path/filepath"
	"reflect"
	"strconv"
	"strings"
	"text/template"
)

const bytesPerLengthOffset = 4

func isDir(path string) (bool, error) {
	fileInfo, err := os.Stat(path)
	if err != nil {
		return false, err
	}
	return fileInfo.IsDir(), err
}

func main() {
	var source string
	var objsStr string

	flag.StringVar(&source, "path", "", "")
	flag.StringVar(&objsStr, "objs", "", "")

	flag.Parse()

	var valid []string
	if objsStr != "" {
		valid = strings.Split(strings.TrimSpace(objsStr), ",")
	}

	if err := encode(source, valid); err != nil {
		fmt.Printf("[ERR]: %v", err)
	}
}

func encode(source string, valid []string) error {
	files := map[string]*ast.File{}

	ok, err := isDir(source)
	if err != nil {
		return err
	}
	if ok {
		// folder
		astFiles, err := parser.ParseDir(token.NewFileSet(), source, nil, parser.AllErrors)
		if err != nil {
			return err
		}
		for _, v := range astFiles {
			files = v.Files
		}
	} else {
		// single file
		astfile, err := parser.ParseFile(token.NewFileSet(), source, nil, parser.AllErrors)
		if err != nil {
			return err
		}
		files[source] = astfile
	}

	// read package
	var packName string
	for _, file := range files {
		packName = file.Name.Name
	}

	e := &env{
		files:    files,
		objs:     map[string]*Value{},
		packName: packName,
		valid:    valid,
	}

	if err := e.encode(); err != nil {
		return err
	}

	out := e.printall()
	for name, str := range out {
		output := []byte(str)

		output, err = format.Source(output)
		if err != nil {
			return err
		}
		if err := ioutil.WriteFile(name, output, 0644); err != nil {
			return err
		}
	}
	return nil
}

// Value is a SSZ type
type Value struct {
	// name of the variable this value represents
	name string
	// name of the Go object this value represents
	obj string
	// n is the fixed size of the value
	n uint64
	// auxiliary int number
	s uint64
	// type of the value
	t Type
	// array of values for a container
	o []*Value
	// type of item for an array
	e *Value
	// auxiliary boolean
	c bool
	// another auxiliary int number
	m uint64
}

func (v *Value) copy() *Value {
	vv := new(Value)
	*vv = *v
	vv.o = make([]*Value, len(v.o))
	for indx := range v.o {
		vv.o[indx] = v.o[indx].copy()
	}
	if v.e != nil {
		vv.e = v.e.copy()
	}
	return vv
}

// Type is a SSZ type
type Type int

const (
	TypeUint Type = iota
	TypeBool
	TypeBytes
	TypeBitVector
	TypeBitList
	TypeVector
	TypeList
	TypeContainer
)

func (t Type) String() string {
	switch t {
	case TypeUint:
		return "uint"
	case TypeBool:
		return "bool"
	case TypeBytes:
		return "bytes"
	case TypeBitVector:
		return "bitvector"
	case TypeBitList:
		return "bitlist"
	case TypeVector:
		return "vector"
	case TypeList:
		return "list"
	case TypeContainer:
		return "container"
	default:
		panic("not found")
	}
}

type env struct {
	files    map[string]*ast.File
	packName string
	raw      map[string]*ast.StructType
	objs     map[string]*Value
	current  string
	order    map[string][]string
	valid    []string
}

func (e *env) printall() map[string]string {
	outs := map[string]string{}

	firstDone := true
	for name, order := range e.order {
		// remove .go prefix and replace if with our own
		ext := filepath.Ext(name)
		name = strings.TrimSuffix(name, ext)
		name += "_encoding.go"

		vvv, ok := e.print(firstDone, order)
		if ok {
			firstDone = false
			outs[name] = vvv
		}
	}
	return outs
}

var errorFunctions = map[string]string{
	"errOffset":              "incorrect offset",
	"errSize":                "incorrect size",
	"errMarshalVector":       "incorrect vector marshalling",
	"errMarshalList":         "incorrect vector list",
	"errMarshalFixedBytes":   "incorrect fixed bytes marshalling",
	"errMarshalDynamicBytes": "incorrect dynamic bytes marshalling",
	"errDivideInt":           "incorrect int divide",
	"errListTooBig":          "incorrect list size, too big",
}

func (e *env) print(first bool, order []string) (string, bool) {
	tmpl := `// Code generated by fastssz. DO NOT EDIT.
	package {{.package}}
	
	import (
		{{ if .errorFuncs }}"fmt"{{ end }}
		ssz "github.com/ferranbt/fastssz"
	)

	{{ if .errorFuncs }}
		var (
			{{ range $key, $value := .errorFuncs }}
			{{ $key }} = fmt.Errorf("{{ $value }}"){{ end }}
		)
	{{ end }}

	{{ range .objs }}
		{{ .Marshal }}
		{{ .Unmarshal }}
		{{ .Size }}
	{{ end }}
	`

	data := map[string]interface{}{
		"package": e.packName,
	}

	if first {
		// include the error functions only once
		data["errorFuncs"] = errorFunctions
	}

	type Obj struct {
		Size, Marshal, Unmarshal string
	}

	objs := []*Obj{}
	for _, name := range order {
		obj, ok := e.objs[name]
		if !ok {
			continue
		}
		objs = append(objs, &Obj{
			Marshal:   e.marshal(name, obj),
			Unmarshal: e.unmarshal(name, obj),
			Size:      e.size(name, obj),
		})
	}

	if len(objs) == 0 {
		return "", false
	}
	data["objs"] = objs
	return execTmpl(tmpl, data), true
}

func appendObjSignature(str string, v *Value) string {
	sig := strings.ToLower(string(v.name[0]))
	return strings.Replace(str, "::", sig, -1)
}

func (e *env) size(name string, v *Value) string {
	tmpl := `// Size returns the ssz encoded size in bytes for the {{.name}} object
	func (:: *{{.name}}) Size() (size int) {
		size = {{.fixed}}{{if .dynamic}}

		{{.dynamic}}
		{{end}}
		return
	}`

	str := execTmpl(tmpl, map[string]interface{}{
		"name":    name,
		"fixed":   v.n,
		"dynamic": v.sizeContainer("size", true),
	})
	return appendObjSignature(str, v)
}

func (e *env) unmarshal(name string, v *Value) string {
	tmpl := `// Unmarshal ssz unmarshals the {{.name}} object
	func (:: *{{.name}}) Unmarshal(buf []byte) error {
		var err error
		{{.unmarshal}}
		return err
	}`

	str := execTmpl(tmpl, map[string]interface{}{
		"name":      name,
		"unmarshal": v.umarshalContainer(true, "buf"),
	})
	return appendObjSignature(str, v)
}

func (e *env) marshal(name string, v *Value) string {
	tmpl := `// Marshal ssz marshals the {{.name}} object
	func (:: *{{.name}}) Marshal() ([]byte, error) {
		buf := make([]byte, ::.Size())
		return ::.MarshalTo(buf[:0])
	}

	// MarshalTo ssz marshals the {{.name}} object to a target array	
	func (:: *{{.name}}) MarshalTo(dst []byte) ([]byte, error) {
		var err error
		{{.offset}}
		{{.marshal}}
		return dst, err
	}`

	data := map[string]interface{}{
		"name":    name,
		"marshal": v.marshalContainer(true),
		"offset":  "",
	}
	if !v.isFixed() {
		data["offset"] = fmt.Sprintf("offset := int(%d)\n", v.n)
	}
	str := execTmpl(tmpl, data)
	return appendObjSignature(str, v)
}

func (v *Value) sizeContainer(name string, start bool) string {
	if !start {
		return fmt.Sprintf(name+" += ::.%s.Size()", v.name)
	}
	out := []string{}
	for indx, v := range v.o {
		if !v.isFixed() {
			out = append(out, fmt.Sprintf("// Field (%d) '%s'\n%s", indx, v.name, v.size(name)))
		}
	}
	return strings.Join(out, "\n\n")
}

func (v *Value) size(name string) string {
	if v.isFixed() {
		if v.t == TypeContainer {
			return v.sizeContainer(name, false)
		}
		if v.n == 1 {
			return name + "++"
		}
		return name + " += " + strconv.Itoa(int(v.n))
	}

	switch v.t {
	case TypeContainer:
		return v.sizeContainer(name, false)

	case TypeBitList:
		fallthrough

	case TypeBytes:
		return fmt.Sprintf(name+" += len(::.%s)", v.name)

	case TypeList:
		fallthrough

	case TypeVector:
		if v.e.isFixed() {
			return fmt.Sprintf("%s += len(::.%s) * %d", name, v.name, v.e.n)
		}
		v.e.name = v.name + "[ii]"
		tmpl := `for ii := 0; ii < len(::.{{.name}}); ii++ {
			{{.size}} += 4
			{{.dynamic}}
		}`
		return execTmpl(tmpl, map[string]interface{}{
			"name":    v.name,
			"size":    name,
			"dynamic": v.e.size(name),
		})

	default:
		panic(fmt.Errorf("size not implemented for type %s", v.t.String()))
	}
}

func (v *Value) marshal() string {
	switch v.t {
	case TypeContainer:
		return v.marshalContainer(false)

	case TypeBytes:
		if v.isFixed() {
			return fmt.Sprintf("if dst, err = ssz.MarshalFixedBytes(dst, ::.%s, %d); err != nil {\n return nil, errMarshalFixedBytes\n}", v.name, v.s)
		}
		// dynamic bytes
		return fmt.Sprintf("if len(::.%s) > %d {\n return nil, errMarshalDynamicBytes\n}\ndst = append(dst, ::.%s...)", v.name, v.m, v.name)

	case TypeUint:
		return fmt.Sprintf("dst = ssz.Marshal%s(dst, ::.%s)", uintVToName(v), v.name)

	case TypeBitList:
		return fmt.Sprintf("dst = append(dst, ::.%s...)", v.name)

	case TypeBool:
		return fmt.Sprintf("dst = ssz.MarshalBool(dst, ::.%s)", v.name)

	case TypeVector:
		if v.e.isFixed() {
			return v.marshalVector()
		}
		fallthrough

	case TypeList:
		return v.marshalList()

	default:
		panic(fmt.Errorf("marshal not implemented for type %s", v.t.String()))
	}
}

func (v *Value) marshalList() string {
	v.e.name = v.name + "[ii]"

	// bound check
	str := fmt.Sprintf("if len(::.%s) > %d {\n return nil, errMarshalList\n}\n", v.name, v.s)

	if v.e.isFixed() {
		tmpl := `for ii := 0; ii < len(::.{{.name}}); ii++ {
			{{.dynamic}}
		}`
		str += execTmpl(tmpl, map[string]interface{}{
			"name":    v.name,
			"dynamic": v.e.marshal(),
		})
		return str
	}

	// encode a list of dynamic objects:
	// 1. write offsets for each
	// 2. marshal each element

	tmpl := `{
		offset = 4 * len(::.{{.name}})
		for ii := 0; ii < len(::.{{.name}}); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			{{.size}}
		}
	}
	for ii := 0; ii < len(::.{{.name}}); ii++ {
		{{.marshal}}
	}`

	str += execTmpl(tmpl, map[string]interface{}{
		"name":    v.name,
		"size":    v.e.size("offset"),
		"marshal": v.e.marshal(),
	})
	return str
}

func (v *Value) marshalVector() (str string) {
	v.e.name = fmt.Sprintf("%s[ii]", v.name)

	tmpl := `if len(::.{{.name}}) != {{.size}} {
		return nil, errMarshalVector
	}
	for ii := 0; ii < {{.size}}; ii++ {
		{{.marshal}}
	}`
	return execTmpl(tmpl, map[string]interface{}{
		"name":    v.name,
		"size":    v.s,
		"marshal": v.e.marshal(),
	})
}

func (v *Value) marshalContainer(start bool) string {
	if !start {
		return fmt.Sprintf("if dst, err = ::.%s.MarshalTo(dst); err != nil {\n return nil, err\n}", v.name)
	}

	offset := v.n
	out := []string{}

	for indx, i := range v.o {
		var str string
		if i.isFixed() {
			// write the content
			str = fmt.Sprintf("// Field (%d) '%s'\n%s\n", indx, i.name, i.marshal())
		} else {
			// write the offset
			str = fmt.Sprintf("// Offset (%d) '%s'\ndst = ssz.WriteOffset(dst, offset)\n%s\n", indx, i.name, i.size("offset"))
			offset += i.n
		}
		out = append(out, str)
	}

	// write the dynamic parts
	for indx, i := range v.o {
		if !i.isFixed() {
			out = append(out, fmt.Sprintf("// Field (%d) '%s'\n%s\n", indx, i.name, i.marshal()))
		}
	}
	return strings.Join(out, "\n")
}

func uintVToName(v *Value) string {
	if v.t != TypeUint {
		panic("not expected")
	}
	switch v.n {
	case 8:
		return "Uint64"
	case 4:
		return "Uint32"
	case 2:
		return "Uint16"
	case 1:
		return "Uint8"
	default:
		panic("not found")
	}
}

func (v *Value) createItem() string {
	// intended to be used in vectors
	if v.t != TypeVector && v.t != TypeList {
		panic("BUG")
	}
	s := "num"
	if v.s != 0 {
		s = strconv.Itoa(int(v.s))
	}
	switch v.e.t {
	case TypeUint:
		return fmt.Sprintf("::.%s = ssz.Extend%s(::.%s, %s)", v.name, uintVToName(v.e), v.name, s)

	case TypeContainer:
		return fmt.Sprintf("::.%s = make([]*%s, %s)", v.name, v.e.obj, s)

	case TypeBytes:
		// [][]byte
		return fmt.Sprintf("::.%s = make([][]byte, %s)", v.name, s)

	default:
		panic(fmt.Sprintf("create not implemented for type %s", v.e.t.String()))
	}
}

func (v *Value) unmarshal(dst, ddd string) string {
	switch v.t {
	case TypeContainer:
		return v.umarshalContainer(false, ddd)

	case TypeBytes:
		if !v.isFixed() {
			// dynamic
			return fmt.Sprintf("::.%s = append(::.%s, %s...)", v.name, v.name, dst)
		}
		return fmt.Sprintf("::.%s = append(::.%s, %s...)", v.name, v.name, ddd)

	case TypeUint:
		return fmt.Sprintf("::.%s = ssz.Unmarshall%s(%s)", v.name, uintVToName(v), ddd)

	case TypeBitList:
		return fmt.Sprintf("::.%s = append(::.%s, %s...)", v.name, v.name, dst)

	case TypeVector:
		// check if its [][]byte we can do something special for that
		if v.e.isFixed() {
			xxx := ddd + fmt.Sprintf("[ii*%d: (ii+1)*%d]", v.e.n, v.e.n)

			tmpl := `{{.create}}
			for ii := 0; ii < {{.size}}; ii++ {
				{{.unmarshal}}
			}`
			return execTmpl(tmpl, map[string]interface{}{
				"create":    v.createItem(),
				"size":      v.s,
				"unmarshal": v.e.unmarshal(dst, xxx),
			})
		}
		fallthrough

	case TypeList:
		return v.unmarshalList()

	case TypeBool:
		return fmt.Sprintf("::.%s = ssz.UnmarshalBool(%s)", v.name, ddd)

	default:
		panic(fmt.Errorf("unmarshal not implemented for type %d", v.t))
	}
}

func (v *Value) unmarshalList() string {
	if v.e.isFixed() {
		maxSize := v.s
		v.s = 0
		dst := fmt.Sprintf("buf[ii*%d: (ii+1)*%d]", v.e.n, v.e.n)

		tmpl := `num, ok := ssz.DivideInt(len(buf), {{.size}})
		if !ok {
			return errDivideInt
		}
		if num > {{.max}} {
			return errListTooBig
		}
		{{.create}}
		for ii := 0; ii < num; ii++ {
			{{.unmarshal}}
		}`
		return execTmpl(tmpl, map[string]interface{}{
			"size":      v.e.n,
			"max":       maxSize,
			"create":    v.createItem(),
			"unmarshal": v.e.unmarshal("buf", dst),
		})
	}

	if v.t == TypeVector {
		panic("it cannot happen")
	}

	tmpl := `num, err := ssz.DecodeDynamicLength(buf, {{.size}})
	if err != nil {
		return err
	}
	{{.create}}
	err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
		{{.unmarshal}}
		return nil
	})
	if err != nil {
		return err
	}`

	data := map[string]interface{}{
		"size": v.s,
	}

	v.s = 0
	data["create"] = v.createItem()

	v.e.name = v.name + "[indx]"
	data["unmarshal"] = v.e.unmarshal("buf", "buf")

	return execTmpl(tmpl, data)
}

func (v *Value) umarshalContainer(start bool, dst string) (str string) {
	if !start {
		tmpl := `if ::.{{.name}} == nil {
			::.{{.name}} = new({{.obj}})
		}
		if err = ::.{{.name}}.Unmarshal({{.dst}}); err != nil {
			return err
		}`
		return execTmpl(tmpl, map[string]interface{}{
			"name": v.name,
			"obj":  v.obj,
			"dst":  dst,
		})
	}

	var offsets []string
	offsetsMatch := map[string]string{}

	for indx, i := range v.o {
		if !i.isFixed() {
			name := "o" + strconv.Itoa(indx)
			if len(offsets) != 0 {
				offsetsMatch[name] = offsets[len(offsets)-1]
			}
			offsets = append(offsets, name)
		}
	}

	// safe check for the size
	var cmp string
	if v.isFixed() {
		cmp = "!="
	} else {
		cmp = "<"
	}

	tmpl := `size := uint64(len(buf))
	if size {{.cmp}} {{.size}} {
		return errSize
	}
	{{if .offsets}}
		tail := buf
		var {{.offsets}} uint64
	{{end}}
	`

	str += execTmpl(tmpl, map[string]interface{}{
		"cmp":     cmp,
		"size":    v.n,
		"offsets": strings.Join(offsets, ", "),
	})

	var o0 uint64

	outs := []string{}
	for indx, i := range v.o {

		// How much it increases on every item
		var incr uint64
		if i.isFixed() {
			incr = i.n
		} else {
			incr = 4
		}

		ddd := fmt.Sprintf("%s[%d:%d]", "buf", o0, o0+incr)
		o0 += incr

		var res string
		if i.isFixed() {
			res = fmt.Sprintf("// Field (%d) '%s'\n%s\n\n", indx, i.name, i.unmarshal(dst, ddd))

		} else {
			// read the offset
			offset := "o" + strconv.Itoa(indx)

			data := map[string]interface{}{
				"indx":   indx,
				"name":   i.name,
				"offset": offset,
				"dst":    ddd,
			}

			if prev, ok := offsetsMatch[offset]; ok {
				data["more"] = fmt.Sprintf(" || %s > %s", prev, offset)
			} else {
				data["more"] = ""
			}

			tmpl := `// Offset ({{.indx}}) '{{.name}}'
			if {{.offset}} = ssz.ReadOffset({{.dst}}); {{.offset}} > size {{.more}} {
				return errOffset
			}
			`
			res = execTmpl(tmpl, data)
		}
		outs = append(outs, res)
	}

	c := 0
	for indx, i := range v.o {
		if !i.isFixed() {

			from := offsets[c]
			var to string
			if c == len(offsets)-1 {
				to = ""
			} else {
				to = offsets[c+1]
			}

			tmpl := `// Field ({{.indx}}) '{{.name}}'
			{
				buf = tail[{{.from}}:{{.to}}]
				{{.unmarshal}}
			}`
			res := execTmpl(tmpl, map[string]interface{}{
				"indx":      indx,
				"name":      i.name,
				"from":      from,
				"to":        to,
				"unmarshal": i.unmarshal("buf", "buf"),
			})
			outs = append(outs, res)
			c++
		}
	}

	str += strings.Join(outs, "\n\n")
	return
}

func (e *env) encode() error {
	e.raw = map[string]*ast.StructType{}
	e.order = map[string][]string{}

	for name, file := range e.files {
		order := []string{}
		for _, dec := range file.Decls {
			if genDecl, ok := dec.(*ast.GenDecl); ok {
				for _, spec := range genDecl.Specs {
					if typeSpec, ok := spec.(*ast.TypeSpec); ok {
						if structType, ok := typeSpec.Type.(*ast.StructType); ok {
							e.raw[typeSpec.Name.Name] = structType
							order = append(order, typeSpec.Name.Name)
						}
					}
				}
			}
		}
		e.order[name] = order
	}

	for name := range e.raw {
		var valid bool
		if e.valid == nil {
			valid = true
		} else {
			valid = contains(name, e.valid)
		}
		if valid {
			if _, err := e.encodeItem(name); err != nil {
				return err
			}
		}
	}
	return nil
}

func contains(i string, j []string) bool {
	for _, a := range j {
		if a == i {
			return true
		}
	}
	return false
}

func (e *env) encodeItem(name string) (*Value, error) {
	v, ok := e.objs[name]
	if !ok {
		var err error
		v, err = e.parseASTStructType(name, e.raw[name])
		if err != nil {
			return nil, err
		}
		v.name = name
		v.obj = name
		e.objs[name] = v
	}
	return v.copy(), nil
}

func (e *env) parseASTStructType(name string, typ *ast.StructType) (*Value, error) {
	v := &Value{
		name: name,
		t:    TypeContainer,
		o:    []*Value{},
	}

	for _, f := range typ.Fields.List {
		name := f.Names[0].Name
		if !isExportedField(name) {
			continue
		}
		if strings.HasPrefix(name, "XXX_") {
			// skip protobuf methods
			continue
		}
		var tags string
		if f.Tag != nil {
			tags = f.Tag.Value
		}

		elem, err := e.parseASTFieldType(tags, f.Type)
		if err != nil {
			return nil, err
		}
		elem.name = name
		v.o = append(v.o, elem)
	}

	// get the total size of the container
	for _, f := range v.o {
		if f.isFixed() {
			v.n += f.n
		} else {
			v.n += bytesPerLengthOffset
			v.c = true
		}
	}
	return v, nil
}

func (e *env) parseASTFieldType(tags string, expr ast.Expr) (*Value, error) {
	switch obj := expr.(type) {
	case *ast.StarExpr:
		return e.encodeItem(obj.X.(*ast.Ident).Name)

	case *ast.ArrayType:
		if isByte(obj.Elt) {
			// []byte
			if tag, ok := getTags(tags, "ssz"); ok && tag == "bitlist" {
				// bitlist
				return &Value{t: TypeBitList}, nil
			}
			size, ok := getTagsInt(tags, "ssz-size")
			if ok {
				// fixed bytes
				return &Value{t: TypeBytes, s: size, n: size}, nil
			}
			max, ok := getTagsInt(tags, "ssz-max")
			if !ok {
				return nil, fmt.Errorf("[]byte expects either ssz-max or ssz-size")
			}
			// dynamic bytes
			return &Value{t: TypeBytes, m: max}, nil
		}
		if isArray(obj.Elt) && isByte(obj.Elt.(*ast.ArrayType).Elt) {
			// [][]byte
			f, s, ok := getTagsTuple(tags, "ssz-size")
			if !ok {
				return nil, fmt.Errorf("[][]byte expects a ssz-size tag")
			}
			if f != 0 {
				// vector
				return &Value{t: TypeVector, c: true, n: f * s, s: f, e: &Value{t: TypeBytes, n: s, s: s}}, nil
			}
			if f == 0 {
				f, ok = getTagsInt(tags, "ssz-max")
				if !ok {
					return nil, fmt.Errorf("ssz-max not set after '?' field on ssz-size")
				}
			}
			// list
			return &Value{t: TypeList, c: true, s: f, e: &Value{t: TypeBytes, n: s, s: s}}, nil
		}

		elem, err := e.parseASTFieldType(tags, obj.Elt)
		if err != nil {
			return nil, err
		}
		if size, ok := getTagsInt(tags, "ssz-size"); ok {
			// fixed vector
			v := &Value{t: TypeVector, s: size, e: elem}
			if elem.isFixed() {
				// set the total size
				v.n = size * elem.n
			}
			return v, err
		}
		// list
		maxSize, ok := getTagsInt(tags, "ssz-max")
		if !ok {
			return nil, fmt.Errorf("slice expects either ssz-max or ssz-size")
		}
		v := &Value{t: TypeList, e: elem, s: maxSize}
		return v, nil

	case *ast.Ident:
		var v *Value
		switch obj.Name {
		case "uint64":
			v = &Value{t: TypeUint, n: 8}
		case "uint32":
			v = &Value{t: TypeUint, n: 4}
		case "uint16":
			v = &Value{t: TypeUint, n: 2}
		case "uint8":
			v = &Value{t: TypeUint, n: 1}
		case "bool":
			v = &Value{t: TypeBool, n: 1}
		case "string":
			v = &Value{t: TypeBytes, c: true}
		default:
			panic(fmt.Errorf("basic type %s not found", obj.Name))
		}
		return v, nil

	case *ast.SelectorExpr:
		name := obj.X.(*ast.Ident).Name
		sel := obj.Sel.Name

		switch name {
		case "bitfield":
			if sel == "Bitlist" {
				// go-bitfield/Bitlist
				return &Value{t: TypeBitList}, nil
			}
		}
		return nil, fmt.Errorf("select for %s.%s not found", name, sel)

	default:
		panic(fmt.Errorf("ast type '%s' not expected", reflect.TypeOf(expr)))
	}
}

func isArray(obj ast.Expr) bool {
	_, ok := obj.(*ast.ArrayType)
	return ok
}

func isByte(obj ast.Expr) bool {
	if ident, ok := obj.(*ast.Ident); ok {
		if ident.Name == "byte" {
			return true
		}
	}
	return false
}

func isExportedField(str string) bool {
	return str[0] <= 90
}

func getTagsTuple(str string, field string) (uint64, uint64, bool) {
	tupleStr, ok := getTags(str, field)
	if !ok {
		return 0, 0, false
	}

	spl := strings.Split(tupleStr, ",")
	if len(spl) != 2 {
		return 0, 0, false
	}

	// first can be either ? or a number
	var first uint64
	if spl[0] == "?" {
		first = 0
	} else {
		tmp, err := strconv.Atoi(spl[0])
		if err != nil {
			return 0, 0, false
		}
		first = uint64(tmp)
	}

	second, err := strconv.Atoi(spl[1])
	if err != nil {
		return 0, 0, false
	}
	return first, uint64(second), true
}

func getTagsInt(str string, field string) (uint64, bool) {
	numStr, ok := getTags(str, field)
	if !ok {
		return 0, false
	}
	num, err := strconv.Atoi(numStr)
	if err != nil {
		return 0, false
	}
	return uint64(num), true
}

func getTags(str string, field string) (string, bool) {
	str = strings.Trim(str, "`")

	for _, tag := range strings.Split(str, " ") {
		if !strings.Contains(tag, ":") {
			return "", false
		}
		spl := strings.Split(tag, ":")
		if len(spl) != 2 {
			return "", false
		}

		tagName, vals := spl[0], spl[1]
		if !strings.HasPrefix(vals, "\"") || !strings.HasSuffix(vals, "\"") {
			return "", false
		}
		if tagName != field {
			continue
		}

		vals = strings.Trim(vals, "\"")
		return vals, true
	}
	return "", false
}

func (v *Value) isFixed() bool {
	switch v.t {
	case TypeUint:
		return true

	case TypeVector:
		return v.e.isFixed()

	case TypeBitList:
		return false

	case TypeBitVector:
		return true

	case TypeBytes:
		if v.s != 0 {
			// fixed bytes
			return true
		}
		// dynamic bytes
		return false

	case TypeList:
		return false

	case TypeContainer:
		return !v.c

	case TypeBool:
		return true

	default:
		panic(fmt.Errorf("is fixed not implemented for type %s", v.t.String()))
	}
}

func execTmpl(tpl string, input interface{}) string {
	tmpl, err := template.New("tmpl").Parse(tpl)
	if err != nil {
		panic(err)
	}
	buf := new(bytes.Buffer)
	if err = tmpl.Execute(buf, input); err != nil {
		panic(err)
	}
	return buf.String()
}
